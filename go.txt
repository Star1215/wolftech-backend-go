./services/helper_service.go
package services

import (
	"context"
	"encoding/base64"
	"errors"
	"fmt"
	"log/slog"
	"os"
	"strconv"

	"github.com/davecgh/go-spew/spew"
	bin "github.com/gagliardetto/binary"
	"github.com/gagliardetto/solana-go"
	associatedtokenaccount "github.com/gagliardetto/solana-go/programs/associated-token-account"
	"github.com/gagliardetto/solana-go/programs/system"
	"github.com/gagliardetto/solana-go/programs/token"
	"github.com/gagliardetto/solana-go/rpc"
	confirm "github.com/gagliardetto/solana-go/rpc/sendAndConfirmTransaction"
	"github.com/gagliardetto/solana-go/rpc/ws"
	"github.com/gagliardetto/solana-go/text"
)

type HelperService struct {
	wsClient  *ws.Client
	rpcClient *rpc.Client
	logger    *slog.Logger
	debug     bool
}

type TokenBalanceChange struct {
	MintStr string
	Change  int64
}

func NewHelperService(rpcClient *rpc.Client, wsClient *ws.Client /*, debug bool*/) *HelperService {
	var logger *slog.Logger
	logger = slog.New(
		slog.NewTextHandler(os.Stdout, &slog.HandlerOptions{
			Level: slog.LevelDebug, // This enables debug logging
		}),
	)


	return &HelperService{
		rpcClient: rpcClient,
		wsClient:  wsClient,
		logger:    logger,
		debug:     true,
	}
}


func (hs *HelperService) GetOrCreateTokenAccount(ctx context.Context, payer *solana.PrivateKey, mint solana.PublicKey, owner solana.PublicKey) (solana.PublicKey, string, error) {

	// 1. Find the associated token address
	hs.logDebug("GetOrCreateTokenAccount called",
		"mint", mint.String(),
		"owner", owner.String())
	ata, _, err := solana.FindAssociatedTokenAddress(owner, mint)
	if err != nil {
		hs.logger.Error("Failed to find ATA", "error", err)
		return solana.PublicKey{}, "", fmt.Errorf("failed to find ATA: %w", err)
	}

	// 2. Check if account already exists
	hs.logDebug("Checking if token account exists", "ata", ata.String())
	_, err = hs.rpcClient.GetTokenAccountBalance(context.Background(), ata, rpc.CommitmentConfirmed)
	if err == nil {
		hs.logDebug("Token account already exists", "ata", ata.String())
		return ata, "", nil // Account exists
	}

	// 3. Create the ATA if it doesn't exist
	hs.logInfo("Creating new associated token account", "ata", ata.String())
	createIx := associatedtokenaccount.NewCreateInstruction(
		payer.PublicKey(), // payer
		owner,             // owner
		mint,              // mint
	).Build()

	// 4. Get recent blockhash
	latestBlockhash, err := hs.rpcClient.GetLatestBlockhash(context.Background(), rpc.CommitmentConfirmed)
	if err != nil {
		hs.logger.Error("Failed to get recent blockhash", "error", err)
		return solana.PublicKey{}, "", fmt.Errorf("failed to get recent blockhash: %w", err)
	}

	// 5. Build transaction
	tx, err := solana.NewTransaction(
		[]solana.Instruction{createIx},
		latestBlockhash.Value.Blockhash,
		solana.TransactionPayer(payer.PublicKey()),
	)
	if err != nil {
		hs.logger.Error("Failed to create transaction", "error", err)
		return solana.PublicKey{}, "", fmt.Errorf("failed to create transaction: %w", err)
	}

	// 6. Sign the transaction
	_, err = tx.Sign(func(key solana.PublicKey) *solana.PrivateKey {
		if key == payer.PublicKey() {
			return payer
		}
		return nil
	})
	if err != nil {
		hs.logger.Error("Failed to sign transaction", "error", err)
		return solana.PublicKey{}, "", fmt.Errorf("failed to sign transaction: %w", err)
	}

	spew.Dump(tx)
	// Pretty print the transaction:
	tx.EncodeTree(text.NewTreeEncoder(os.Stdout, "Transfer SOL"))
	// 7. Send with automatic confirmation
	sig, err := confirm.SendAndConfirmTransaction(
		ctx,
		hs.rpcClient,
		hs.wsClient,
		tx,
	)

	hs.logInfo("Successfully created token account",
		"ata", ata.String(),
		"signature", sig.String())
	return ata, sig.String(), nil
}

func (hs *HelperService) DecodeTransaction(encodedTx string) (*solana.Transaction, error) {
	hs.logDebug("Decoding transaction", "encodedTx", encodedTx[:min(20, len(encodedTx))]+"...")
	txData, err := base64.StdEncoding.DecodeString(encodedTx)
	if err != nil {

		hs.logger.Error("Base64 decode failed", "error", err)
		return nil, fmt.Errorf("base64 decode failed: %w", err)
	}

	// Create a new bin decoder from the bytes
	decoder := bin.NewBinDecoder(txData)
	// Deserialize the transaction
	var tx solana.Transaction
	if err := decoder.Decode(&tx); err != nil {
		hs.logger.Error("Transaction deserialization failed", "error", err)
		return nil, fmt.Errorf("transaction deserialization failed: %w", err)
	}
	hs.logDebug("Transaction decoded successfully",
		"numInstructions", len(tx.Message.Instructions))
	return &tx, nil
}

func (hs *HelperService) ValidateTokenAddress(address string) (solana.PublicKey, error) {
	hs.logDebug("Validating token address", "address", address)
	pubkey, err := solana.PublicKeyFromBase58(address)
	if err != nil {
		hs.logger.Error("Invalid token address", "address", address, "error", err)
		return solana.PublicKey{}, fmt.Errorf("invalid token address: %w", err)
	}

	// Verify the token mint exists on chain
	mintInfo, err := hs.rpcClient.GetAccountInfo(context.Background(), pubkey)
	if err != nil {
		hs.logger.Error("Failed to verify token mint", "mint", pubkey.String(), "error", err)
		return solana.PublicKey{}, fmt.Errorf("failed to verify token mint: %w", err)
	}
	if mintInfo == nil {
		hs.logger.Error("Token mint account does not exist", "mint", pubkey.String())
		return solana.PublicKey{}, fmt.Errorf("token mint account does not exist")
	}
	hs.logDebug("Token address validated successfully", "mint", pubkey.String())
	return pubkey, nil
}

func (hs *HelperService) GetTokenDecimals(mint solana.PublicKey) (uint8, error) {
	hs.logDebug("Getting token decimals", "mint", mint.String())
	// Get the account info
	acc, err := hs.rpcClient.GetAccountInfo(context.Background(), mint)
	if err != nil {
		hs.logger.Error("Failed to get account info", "mint", mint.String(), "error", err)
		return 0, fmt.Errorf("failed to get account info: %w", err)
	}

	if acc == nil {
		hs.logger.Error("Token mint account not found", "mint", mint.String())
		return 0, fmt.Errorf("token mint account not found")
	}

	// Decode the mint data
	var mintData token.Mint
	if err := bin.NewBorshDecoder(acc.GetBinary()).Decode(&mintData); err != nil {
		hs.logger.Error("Failed to decode mint data", "mint", mint.String(), "error", err)
		return 0, fmt.Errorf("failed to decode mint data: %w", err)
	}
	hs.logDebug("Retrieved token decimals",
		"mint", mint.String(),
		"decimals", mintData.Decimals)
	return mintData.Decimals, nil
}

func (hs *HelperService) DeserializeAndExtractAccounts(encodedTx string) ([]solana.PublicKey, error) {
	hs.logDebug("Deserializing and extracting accounts from transaction")
	tx, err := hs.DecodeTransaction(encodedTx)
	if err != nil {
		return nil, err
	}

	var accounts []solana.PublicKey
	for _, instr := range tx.Message.Instructions {
		for _, keyIndex := range instr.Accounts {
			if int(keyIndex) < len(tx.Message.AccountKeys) {
				accountKey := tx.Message.AccountKeys[keyIndex]
				accounts = append(accounts, accountKey)
			}
		}
	}
	hs.logDebug("Extracted accounts from transaction",
		"numAccounts", len(accounts))
	return accounts, nil
}

func (hs *HelperService) GetTokenBalance(account solana.PublicKey) (uint64, error) {
	hs.logDebug("Getting token balance", "account", account.String())
	balance, err := hs.rpcClient.GetTokenAccountBalance(
		context.Background(),
		account,
		rpc.CommitmentConfirmed,
	)
	if err != nil {
		hs.logger.Error("Failed to get token balance", "account", account.String(), "error", err)
		return 0, fmt.Errorf("failed to get token balance: %w", err)
	}

	amount, err := strconv.ParseUint(balance.Value.Amount, 10, 64)
	if err != nil {
		hs.logger.Error("Failed to parse token balance",
			"account", account.String(),
			"rawAmount", balance.Value.Amount,
			"error", err)
		return 0, fmt.Errorf("failed to parse token balance: %w", err)
	}
	hs.logDebug("Retrieved token balance",
		"account", account.String(),
		"balance", amount)
	return amount, nil
}

func (hs *HelperService) CreateTipTransaction(ctx context.Context, feePayerPublicKey solana.PublicKey, tipAmount uint64, tipAccount solana.PublicKey) (*solana.Transaction, error) {
	recent, err := hs.rpcClient.GetLatestBlockhash(ctx, rpc.CommitmentFinalized)
	if err != nil {
		return nil, fmt.Errorf("failed to get recent blockhash: %w", err)
	}

	tx, err := solana.NewTransaction(
		[]solana.Instruction{
			system.NewTransferInstruction(
				tipAmount,
				feePayerPublicKey,
				tipAccount,
			).Build(),
		},
		recent.Value.Blockhash,
		solana.TransactionPayer(feePayerPublicKey),
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create transaction: %w", err)
	}

	return tx, nil
}

func (hs *HelperService) contains(slice []string, item string) bool {
	for _, s := range slice {
		if s == item {
			return true
		}
	}
	return false
}

func (hs *HelperService) remove(slice []string, item string) []string {
	for i, s := range slice {
		if s == item {
			return append(slice[:i], slice[i+1:]...)
		}
	}
	return slice
}

// GetTokenBalanceChangeForMint extracts token balance changes from a transaction
func (hs *HelperService) GetTokenBalanceChangeForMint(txID string, mintAddress, ownerAddress string) (*TokenBalanceChange, error) {
	tx, err := hs.rpcClient.GetTransaction(context.Background(), solana.MustSignatureFromBase58(txID), nil)
	if err != nil {
		return nil, fmt.Errorf("failed to get transaction: %w", err)
	}

	if tx.Meta == nil {
		return nil, errors.New("transaction metadata not available")
	}

	var preAmount, postAmount int64

	// Parse pre-token balances
	for _, balance := range tx.Meta.PreTokenBalances {
		if balance.Mint.String() == mintAddress && balance.Owner.String() == ownerAddress {
			amount, err := strconv.ParseInt(balance.UiTokenAmount.Amount, 10, 64)
			if err != nil {
				return nil, fmt.Errorf("failed to parse pre-token amount: %w", err)
			}
			preAmount = amount
			break
		}
	}

	// Parse post-token balances
	for _, balance := range tx.Meta.PostTokenBalances {
		if balance.Mint.String() == mintAddress && balance.Owner.String() == ownerAddress {
			amount, err := strconv.ParseInt(balance.UiTokenAmount.Amount, 10, 64)
			if err != nil {
				return nil, fmt.Errorf("failed to parse post-token amount: %w", err)
			}
			postAmount = amount
			break
		}
	}

	change := postAmount - preAmount
	if change == 0 {
		return nil, nil
	}

	return &TokenBalanceChange{
		MintStr: mintAddress,
		Change:  change,
	}, nil
}

func (hs *HelperService) logDebug(msg string, args ...any) {
	if hs.debug {
		hs.logger.Debug(msg, args...)
	}
}

func (hs *HelperService) logInfo(msg string, args ...any) {
	if hs.debug {
		hs.logger.Info(msg, args...)
	}
}


./services/jito_service.go
package services

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"log/slog"
	"os"
	"time"

	"github.com/gagliardetto/solana-go"
	jitorpc "github.com/jito-labs/jito-go-rpc"
)

// JitoService handles MEV bundle submissions to Jito
type JitoService struct {
	jitoClient *jitorpc.JitoJsonRpcClient
	logger     *slog.Logger
	debug      bool
}

// NewJitoService creates a new JitoService instance
func NewJitoService(jitoClient *jitorpc.JitoJsonRpcClient) *JitoService {
	var logger *slog.Logger
	logger = slog.New(
		slog.NewTextHandler(os.Stdout, &slog.HandlerOptions{
			Level: slog.LevelDebug, // This enables debug logging
		}),
	)
	return &JitoService{
		jitoClient: jitoClient,
		logger:     logger,
		debug:      true,
	}
}

// BundleResult contains the result of a bundle submission
type BundleResult struct {
	BundleID       string
	Status         string
	Error          error
	Transactions   []string
	BalanceChanges []TokenBalanceChange
}

// sendAndConfirmTransaction sends and confirms a transaction
func (js *JitoService) SubmitBundle(ctx context.Context /*bundle [][]string*/, transactions []solana.Transaction) (*BundleResult, error) {
	bundle := make([][]string, 1) // Single bundle with multiple transactions
	for _, tx := range transactions {
		// Serialize transaction
		serializedTx, err := tx.MarshalBinary()
		if err != nil {
			js.logger.Error("failed to serialize transaction:", "error", err)
			return nil, fmt.Errorf("failed to serialize transaction: %w", err)
		}
		// Encode to base64 and add to bundle
		bundle[0] = append(bundle[0], base64.StdEncoding.EncodeToString(serializedTx))
	}
	// Send the bundle
	bundleIdRaw, err := js.jitoClient.SendBundle(bundle)
	if err != nil {
		js.logger.Error("failed to send bundle:", "error", err)
		return nil, fmt.Errorf("failed to send bundle: %w", err)
	}

	var bundleId string
	if err := json.Unmarshal(bundleIdRaw, &bundleId); err != nil {
		js.logger.Error("failed to unmarshal bundle ID:", "error", err)
		return nil, fmt.Errorf("failed to unmarshal bundle ID: %w", err)
	}

	// Wait for bundle confirmation
	result, err := js.waitForBundleConfirmation(ctx, bundleId)
	if err != nil {
		js.logger.Error("bundle submission failed:", "error", err)
		return result, fmt.Errorf("bundle submission failed: %w", err)
	}

	return result, nil
	
}

// waitForBundleConfirmation polls for bundle status until finalized or timeout
func (js *JitoService) waitForBundleConfirmation(ctx context.Context, bundleId string) (*BundleResult, error) {
	result := &BundleResult{
		BundleID: bundleId,
	}

	maxAttempts := 60
	pollInterval := 2 * time.Second

	for attempt := 1; attempt <= maxAttempts; attempt++ {
		select {
		case <-ctx.Done():
			return result, ctx.Err()
		case <-time.After(pollInterval):
		}

		statusResponse, err := js.jitoClient.GetBundleStatuses([]string{bundleId})
		if err != nil {
			if js.debug {
				fmt.Printf("Attempt %d: Failed to get bundle status: %v\n", attempt, err)
			}
			continue
		}

		if len(statusResponse.Value) == 0 {
			if js.debug {
				fmt.Printf("Attempt %d: No bundle status available\n", attempt)
			}
			continue
		}

		bundleStatus := statusResponse.Value[0]
		result.Status = bundleStatus.ConfirmationStatus
		result.Transactions = bundleStatus.Transactions

		if js.debug {
			fmt.Printf("Attempt %d: Bundle status: %s\n", attempt, bundleStatus.ConfirmationStatus)
		}

		switch bundleStatus.ConfirmationStatus {
		case "processed", "confirmed":
			// Continue polling
		case "finalized":
			if bundleStatus.Err.Ok != nil {
				result.Error = fmt.Errorf("bundle execution failed: %v", bundleStatus.Err.Ok)
				return result, result.Error
			}
			return result, nil
		default:
			result.Error = fmt.Errorf("unexpected status: %s", bundleStatus.ConfirmationStatus)
			return result, result.Error
		}
	}

	result.Error = fmt.Errorf("maximum polling attempts reached")
	return result, result.Error
}

func (js *JitoService) logDebug(msg string, args ...any) {
	if js.debug {
		js.logger.Debug(msg, args...)
	}
}

func (js *JitoService) logInfo(msg string, args ...any) {
	if js.debug {
		js.logger.Info(msg, args...)
	}
}



./services/jupiter_service.go
package services

import (
	"context"
	"encoding/base64"
	"fmt"
	"log/slog"
	"os"

	bin "github.com/gagliardetto/binary"
	"github.com/gagliardetto/solana-go"
	"github.com/ilkamo/jupiter-go/jupiter"
)

type JupiterService struct {
	jupClient *jupiter.ClientWithResponses
	logger    *slog.Logger
	debug     bool
}

type SwapResult struct {
	Transaction        *solana.Transaction
	EstimatedAmountIn  uint64
	EstimatedAmountOut uint64
	PriceImpactPct     float64
	Signature          solana.Signature
}

type SwapParams struct {
	UserWalletAddress       string
	InputMintStr            string
	OutputMintStr           string
	Amount                  float32 // in lamports or token base units
	SlippageBps             float32 // basis points (1 = 0.01%)
	PriorityFee             int     // micro lamports
	DynamicComputeUnitLimit bool
	AsLegacyTx              bool
}

func NewJupiterService(jupClient *jupiter.ClientWithResponses) *JupiterService {
	var logger *slog.Logger
	logger = slog.New(
		slog.NewTextHandler(os.Stdout, &slog.HandlerOptions{
			Level: slog.LevelDebug, // This enables debug logging
		}),
	)

	return &JupiterService{
		jupClient: jupClient,
		logger:    logger,
		debug:     true,
	}
}

func (js *JupiterService) GetSwapTransaction(ctx context.Context, params SwapParams) (*SwapResult, error) {
	// 1. Get quote
	js.logDebug("Getting quote for swap",
		"inputMint", params.InputMintStr,
		"outputMint", params.OutputMintStr,
		"amount", params.Amount,
		"slippage", params.SlippageBps)

	quoteResponse, err := js.jupClient.GetQuoteWithResponse(ctx, &jupiter.GetQuoteParams{
		InputMint:   params.InputMintStr,
		OutputMint:  params.OutputMintStr,
		Amount:      params.Amount,
		SlippageBps: &params.SlippageBps,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get quote: %w", err)
	}

	if quoteResponse.JSON200 == nil {
		return nil, fmt.Errorf("invalid quote response: %s", string(quoteResponse.Body))
	}
	quote := quoteResponse.JSON200

	// 2. Prepare swap request
	js.logDebug("Preparing swap request", "expected amount:", quote.OutAmount)

	prioritizationFeeLamports := &struct {
		JitoTipLamports              *int `json:"jitoTipLamports,omitempty"`
		PriorityLevelWithMaxLamports *struct {
			MaxLamports   *int    `json:"maxLamports,omitempty"`
			PriorityLevel *string `json:"priorityLevel,omitempty"`
		} `json:"priorityLevelWithMaxLamports,omitempty"`
	}{
		PriorityLevelWithMaxLamports: &struct {
			MaxLamports   *int    `json:"maxLamports,omitempty"`
			PriorityLevel *string `json:"priorityLevel,omitempty"`
		}{
			MaxLamports:   new(int),
			PriorityLevel: new(string),
		},
	}

	*prioritizationFeeLamports.PriorityLevelWithMaxLamports.MaxLamports = 1000
	*prioritizationFeeLamports.PriorityLevelWithMaxLamports.PriorityLevel = "high"

	swapRequest := jupiter.PostSwapJSONRequestBody{
		PrioritizationFeeLamports: prioritizationFeeLamports,
		QuoteResponse:             *quote,
		UserPublicKey:             params.UserWalletAddress,
		DynamicComputeUnitLimit:   &params.DynamicComputeUnitLimit,
	}

	// 3. Get swap transaction
	js.logDebug("Getting swap transaction")
	swapResponse, err := js.jupClient.PostSwapWithResponse(ctx, swapRequest)
	if err != nil {
		return nil, fmt.Errorf("failed to get swap transaction: %w", err)
	}

	if swapResponse.JSON200 == nil {
		return nil, fmt.Errorf("invalid swap response: %s", string(swapResponse.Body))
	}
	swap := swapResponse.JSON200

	// 4. Deserialize transaction
	js.logDebug("Deserializing transaction")
	txData, err := base64.StdEncoding.DecodeString(swap.SwapTransaction)
	if err != nil {
		return nil, fmt.Errorf("failed to decode transaction: %w", err)
	}

	var tx solana.Transaction
	err = tx.UnmarshalWithDecoder(bin.NewBinDecoder(txData))
	if err != nil {
		return nil, fmt.Errorf("failed to deserialize transaction: %w", err)
	}

	return &SwapResult{
		Transaction: &tx,
	}, nil
}

func (js *JupiterService) logDebug(msg string, args ...any) {
	if js.debug {
		js.logger.Debug(msg, args...)
	}
}

func (js *JupiterService) logInfo(msg string, args ...any) {
	if js.debug {
		js.logger.Info(msg, args...)
	}
}



./controllers/token_controller.go
package controllers

import (
	"context"
	"echo-mongo-api/configs"
	"echo-mongo-api/models"
	"echo-mongo-api/responses"
	"echo-mongo-api/services"
	"fmt"
	"log"
	"log/slog"
	"math/big"
	"net/http"
	"os"
	"strconv"
	"time"

	"github.com/gagliardetto/solana-go"
	"github.com/gagliardetto/solana-go/rpc"
	"github.com/gagliardetto/solana-go/rpc/ws"
	"github.com/labstack/echo/v4"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

type TokenController struct {
	helpService    *services.HelperService
	jupitorService *services.JupiterService
	jitoService    *services.JitoService
	rpcClient      *rpc.Client
	wsClient       *ws.Client
	logger         *slog.Logger
	debug          bool
}

func NewTokenController(
	helpService *services.HelperService,
	jupitorService *services.JupiterService,
	jitoService *services.JitoService,
	rpcClient *rpc.Client,
	wsClient *ws.Client,
) *TokenController {
	var logger *slog.Logger
	logger = slog.New(
		slog.NewTextHandler(os.Stdout, &slog.HandlerOptions{
			Level: slog.LevelDebug, // This enables debug logging
		}),
	)
	return &TokenController{
		helpService:    helpService,
		jupitorService: jupitorService,
		jitoService:    jitoService,
		rpcClient:      rpcClient,
		wsClient:       wsClient,
		logger:         logger,
		debug:          true,
	}
}

type TokenTransaction struct {
	Transaction  *solana.Transaction
	TokenAddress string
	TokenTicker  string
}

type BuyTokensRequest struct {
	SolAmount     float64 `json:"solAmount" validate:"required"`
	BundleID      int     `json:"bundleId" validate:"required"`
	UserPublicKey string  `json:"userPublicKey" validate:"required"`
}

const (
	LAMPORTS_PER_SOL    = 1000000000
	CHUNK_SIZE          = 4
	MAIN_RETRIES        = 1
	DEPOSIT_RETRIES     = 3
	INITIAL_RETRY_DELAY = 1 * time.Second
	BACKOFF_FACTOR      = 2
)

var userDepositCollection *mongo.Collection = configs.GetCollection(configs.DB, "user_deposits")

func (tc *TokenController) BuyTokens(c echo.Context) error {
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	fmt.Println("Starting buy tokens processing")
	var req BuyTokensRequest
	if err := c.Bind(&req); err != nil {
		return c.JSON(http.StatusBadRequest, responses.TokenResponse{
			Status:  http.StatusBadRequest,
			Message: "error",
			Data:    &echo.Map{"data": err.Error()},
		})
	}

	// Validate input
	if req.SolAmount <= 0 || req.UserPublicKey == "" {
		return c.JSON(http.StatusBadRequest, responses.TokenResponse{
			Status:  http.StatusBadRequest,
			Message: "Invalid required parameters",
			Data:    &echo.Map{"data": req.UserPublicKey}, //fix it
		})
	}

	// Validate user public key
	userPubkey, err := solana.PublicKeyFromBase58(req.UserPublicKey)
	if err != nil {
		log.Printf("Invalid user wallet address: %s", userPubkey)
		return c.JSON(http.StatusBadRequest, responses.TokenResponse{
			Status:  http.StatusBadRequest,
			Message: "Invalid user public key",
			Data:    &echo.Map{"data": err.Error()},
		})
	}

	relayer, err := solana.PrivateKeyFromBase58(configs.EnvRelayerPrivateKey())
	if err != nil {
		tc.logger.Error("Failed to load relayer private key", "error", err)
		return c.JSON(http.StatusInternalServerError, responses.TokenResponse{
			Status:  http.StatusInternalServerError,
			Message: "error",
			Data:    &echo.Map{"data": err.Error()},
		})
	}

	bundleId := req.BundleID
	solDeposit := req.SolAmount
	// feeAmount := solDeposit * 0.05

	// Verify bundle exists
	bundle := bundleCollection.FindOne(ctx, bson.M{"_bid": bundleId})
	if bundle.Err() != nil {
		tc.logger.Error("Bundle not found", "bundleId", bundleId, "error", bundle.Err())
		return c.JSON(http.StatusNotFound, responses.TokenResponse{
			Status:  http.StatusNotFound,
			Message: "Bundle not found",
			Data:    &echo.Map{"data": bundle.Err().Error()},
		})
	}

	// Get memes for this bundle
	log.Printf("Querying memes for bundle ID: %d", bundleId)
	cursor, err := memeCollection.Find(ctx, bson.M{"_bid": strconv.Itoa(bundleId)})
	if err != nil {
		tc.logger.Error("Failed to find memes for bundle", "bundleId", bundleId, "error", err)
		return c.JSON(http.StatusInternalServerError, responses.TokenResponse{
			Status:  http.StatusInternalServerError,
			Message: "Memes for requested bundle not found",
			Data:    &echo.Map{"data": err.Error()},
		})
	}
	defer cursor.Close(ctx)

	var memes []models.Meme
	if err = cursor.All(ctx, &memes); err != nil {
		tc.logger.Error("Failed to decode memes", "error", err)
		return c.JSON(http.StatusInternalServerError, responses.TokenResponse{
			Status:  http.StatusInternalServerError,
			Message: "Iterating error in MongoDB",
			Data:    &echo.Map{"data": err.Error()},
		})
	}
	tc.logger.Debug("Verified tokens in bundle", "count", len(memes), "bundle", bundleId)

	// 1. Create token accounts if needed
	accountCreationFailedTokens := make([]string, 0)
	processableTokens := make([]models.Meme, 0)
	for _, meme := range memes {
		tc.logger.Debug("Checking token account", "ticker", meme.MemeTicker)
		memeMint, err := solana.PublicKeyFromBase58(meme.MemeAddress)
		if err != nil {
			tc.logger.Error("Invalid meme address", "ticker", meme.MemeTicker, "error", err)
			accountCreationFailedTokens = append(accountCreationFailedTokens, meme.MemeTicker)
			continue
		}
		tokenAccount, _, err := tc.helpService.GetOrCreateTokenAccount(ctx, &relayer, memeMint, relayer.PublicKey())
		if err != nil {
			tc.logger.Error("Failed to get/create token account", "ticker", meme.MemeTicker, "error", err)
			accountCreationFailedTokens = append(accountCreationFailedTokens, meme.MemeTicker)
			continue
		}
		tc.logger.Debug("Token account ready", "ticker", meme.MemeTicker, "account", tokenAccount.String())
		processableTokens = append(processableTokens, meme)
	}

	cntProcessableTokens := len(processableTokens)
	tc.logger.Info("Successfully prepared for processing", "memes:", cntProcessableTokens)

	if cntProcessableTokens == 0 {
		return c.JSON(http.StatusBadRequest, responses.TokenResponse{
			Status:  http.StatusBadRequest,
			Message: "Failed to prepare all token accounts",
			Data:    &echo.Map{"data": accountCreationFailedTokens},
		})
	}
	// Calculate SOL per token
	solPerToken := uint64(solDeposit * LAMPORTS_PER_SOL / float64(len(processableTokens)))
	tc.logger.Debug("Calculated SOL per token", "solPerToken", solPerToken)

	// Phase 2: Process buy transactions
	transactionFailedTokens := make([]string, 0)
	jitoFailedTokens := make([]string, 0)
	retryMainProcessing := 0
	transactionBuffer := make([]TokenTransaction, 0)
	successfulTransactions := make([]TokenTransaction, 0)

	// Main processing loop
	for len(processableTokens) > 0 || (len(jitoFailedTokens) > 0 && retryMainProcessing < MAIN_RETRIES) {
		tc.logger.Debug("Processing loop",
			"remainingTokens", len(processableTokens),
			"jitoFailed", len(jitoFailedTokens),
			"retryCount", retryMainProcessing)
		// When remaining tokens are less than chunk size, add Jito failed tokens to queue
		if len(processableTokens) < CHUNK_SIZE && len(jitoFailedTokens) > 0 && retryMainProcessing < MAIN_RETRIES {
			retryMainProcessing++
			for _, address := range jitoFailedTokens {
				for _, token := range memes {
					if token.MemeAddress == address {
						processableTokens = append(processableTokens, token)
						break
					}
				}
			}
			jitoFailedTokens = make([]string, 0)
		}

		// Process tokens until we fill the buffer or run out
		for len(transactionBuffer) < CHUNK_SIZE && len(processableTokens) > 0 {
			token := processableTokens[0]
			processableTokens = processableTokens[1:]

			params := services.SwapParams{
				UserWalletAddress:       relayer.PublicKey().String(),
				InputMintStr:            "So11111111111111111111111111111111111111112",
				OutputMintStr:           token.MemeAddress,    // USDC
				Amount:                  float32(solPerToken), // 0.1 SOL
				SlippageBps:             50,                   // 0.5%
				PriorityFee:             1000,                 // 1000 lamports priority fee
				DynamicComputeUnitLimit: true,
			}

			result, err := tc.jupitorService.GetSwapTransaction(ctx, params)
			if err != nil {
				tc.logger.Error("Failed to create buy transaction", "token", token.MemeTicker, "error", err)
				transactionFailedTokens = append(transactionFailedTokens, token.MemeAddress)
				continue
			}
			if err != nil {
				tc.logger.Error("Failed to create buy transaction", "token", token.MemeTicker, "error", err)
				transactionFailedTokens = append(transactionFailedTokens, token.MemeAddress)
				continue
			}

			// Sign the transaction immediately
			_, err = result.Transaction.Sign(func(key solana.PublicKey) *solana.PrivateKey {
				if key == relayer.PublicKey() {
					return &relayer
				}
				return nil
			})
			if err != nil {
				tc.logger.Error("Failed to sign swap transaction", "token", token.MemeTicker, "error", err)
				transactionFailedTokens = append(transactionFailedTokens, token.MemeAddress)
				continue
			}

			_, err = tc.rpcClient.SimulateTransaction(ctx, result.Transaction)
			if err != nil {
				tc.logger.Error("Transaction simulation failed", "token", token.MemeTicker, "error", err)
				transactionFailedTokens = append(transactionFailedTokens, token.MemeAddress)
				continue
			}
			tc.logDebug("Transaction simulation success", "token", token.MemeTicker)

			// Only add to buffer if signed successfully
			if len(result.Transaction.Signatures) > 0 {
				transactionBuffer = append(transactionBuffer, TokenTransaction{
					Transaction:  result.Transaction,
					TokenAddress: token.MemeAddress,
					TokenTicker:  token.MemeTicker,
				})
			} else {
				tc.logger.Error("Transaction not signed", "token", token.MemeTicker)
				transactionFailedTokens = append(transactionFailedTokens, token.MemeAddress)
			}
		}

		// Submit bundle when we have a full chunk or no more tokens to process
		if len(transactionBuffer) == CHUNK_SIZE || (len(processableTokens) == 0 && len(transactionBuffer) > 0) {
			// Submit bundle via Jito

			// Create tip transaction
			tipAmount := uint64(100000) // 0.00001 SOL as tip
			tipTx, err := tc.helpService.CreateTipTransaction(
				ctx,
				relayer.PublicKey(),
				tipAmount,
				solana.MustPublicKeyFromBase58(configs.EnvJitoTipAccount()),
			)
			if err != nil {
				tc.logger.Error("Failed to create tip transaction", "error", err)
				// Mark all transactions in buffer as failed
				for _, tx := range transactionBuffer {
					jitoFailedTokens = append(jitoFailedTokens, tx.TokenAddress)
				}
				transactionBuffer = make([]TokenTransaction, 0)
				continue
			}

			// Sign the tip transaction
			_, err = tipTx.Sign(func(key solana.PublicKey) *solana.PrivateKey {
				if key == relayer.PublicKey() {
					return &relayer
				}
				return nil
			})
			if err != nil {
				tc.logger.Error("Failed to sign tip transaction", "error", err)
				for _, tx := range transactionBuffer {
					jitoFailedTokens = append(jitoFailedTokens, tx.TokenAddress)
				}
				transactionBuffer = make([]TokenTransaction, 0)
				continue
			}

			bundleTransactions := make([]solana.Transaction, 0, len(transactionBuffer)+1)
			bundleTransactions = append(bundleTransactions, *tipTx)
			for _, tx := range transactionBuffer {
				bundleTransactions = append(bundleTransactions, *tx.Transaction)
			}

			bundleResult, err := tc.jitoService.SubmitBundle(ctx, bundleTransactions)
			if err != nil {
				tc.logger.Error("Failed to submit bundle", "error", err)
				// Record failed tokens
				for _, tx := range transactionBuffer {
					jitoFailedTokens = append(jitoFailedTokens, tx.TokenAddress)
				}
			} else {
				tc.logger.Info("Bundle submitted successfully",
					"bundleId", bundleResult.BundleID,
					"status", bundleResult.Status,
					"numTransactions", len(bundleTransactions),
					"tokens", func() []string {
						var tickers []string
						for _, tx := range transactionBuffer {
							tickers = append(tickers, tx.TokenTicker)
						}
						return tickers
					}())
				// Track successful transactions and their balances
				for _, tx := range transactionBuffer {
					successfulTransactions = append(successfulTransactions, tx)
				}

				// Process balance changes for successful transactions
				// tc.processBalanceChanges(
				// 	ctx,
				// 	successfulTransactions,
				// 	relayer.PublicKey(),
				// 	bundleId,
				// 	req.UserPublicKey,
				// )
			}
			transactionBuffer = make([]TokenTransaction, 0)
		}
	}

	// Phase 3: Process remaining failed tokens via normal RPC
	finalFailedTokens := make([]string, 0)
	finalFailedTokens = append(finalFailedTokens, transactionFailedTokens...)
	finalFailedTokens = append(finalFailedTokens, jitoFailedTokens...)

	tokensToRetry := make([]models.Meme, 0)
	for _, address := range finalFailedTokens {
		for _, token := range memes {
			if token.MemeAddress == address {
				tokensToRetry = append(tokensToRetry, token)
				break
			}
		}
	}

	return c.JSON(http.StatusOK, responses.TokenResponse{
		Status:  http.StatusOK,
		Message: "success",
		Data:    &echo.Map{"data": "Token purchase initiated"},
	})
}

func (tc *TokenController) processBalanceChanges(
	ctx context.Context,
	transactions []TokenTransaction,
	relayerPubkey solana.PublicKey,
	bundleId int,
	userWallet string,
) error {
	// Get bundle details from database
	var bundle models.Bundle
	err := bundleCollection.FindOne(ctx, bson.M{"_bid": bundleId}).Decode(&bundle)
	if err != nil {
		tc.logger.Error("failed to find bundle: ", "error", err)
		return fmt.Errorf("failed to find bundle: %w", err)
	}

	// Get existing user deposit if any
	var existingDeposit models.UserDeposit
	err = userDepositCollection.FindOne(ctx, bson.M{"wallet": userWallet}).Decode(&existingDeposit)
	if err != nil && err != mongo.ErrNoDocuments {
		return fmt.Errorf("failed to query user deposit: %w", err)
	}

	// Find existing bundle holding if any
	var existingHolding *models.UserHolding
	for i, deposit := range existingDeposit.Deposits {
		if deposit.BundleID == bundleId {
			existingHolding = &existingDeposit.Deposits[i]
			break
		}
	}

	// Prepare token allocations map
	tokenAllocations := make(map[string]models.TokenAllocation)

	// Initialize with existing allocations if any
	if existingHolding != nil {
		for _, alloc := range existingHolding.Tokens {
			tokenAllocations[alloc.Mint] = alloc
		}
	}

	// Process transactions to calculate actual SOL spent per token
	tokenSOLSpent := make(map[string]float64)
	totalTokenSOLSpent := 0.0

	for _, tx := range transactions {
		txDetails, err := tc.rpcClient.GetTransaction(ctx, tx.Transaction.Signatures[0], nil)
		if err != nil || txDetails.Meta == nil {
			continue // Skip failed transactions
		}

		// Calculate SOL spent in this transaction (preBalance - postBalance - fee)
		solSpent := float64(txDetails.Meta.PreBalances[0]-txDetails.Meta.PostBalances[0])/float64(solana.LAMPORTS_PER_SOL) -
			float64(txDetails.Meta.Fee)/float64(solana.LAMPORTS_PER_SOL)

		// Distribute SOL spent among tokens in this transaction
		tokensInTx := make(map[string]bool)
		for _, tokenBalance := range txDetails.Meta.PostTokenBalances {
			if tokenBalance.Owner == nil || *tokenBalance.Owner != relayerPubkey {
				continue
			}
			tokensInTx[tokenBalance.Mint.String()] = true
		}

		solPerTokenInTx := solSpent / float64(len(tokensInTx))
		for mint := range tokensInTx {
			tokenSOLSpent[mint] += solPerTokenInTx
			totalTokenSOLSpent += solPerTokenInTx
		}
	}

	// Update token allocations with new purchases
	for _, memeInfo := range bundle.BundleMemesInfo {
		mint := memeInfo.TokenAddress
		currentAlloc, exists := tokenAllocations[mint]
		if !exists {
			currentAlloc = models.TokenAllocation{
				Mint:   mint,
				Ticker: memeInfo.TokenTicker,
			}
		}

		// Get token amount from transactions
		amount := "0"
		for _, tx := range transactions {
			txDetails, err := tc.rpcClient.GetTransaction(ctx, tx.Transaction.Signatures[0], nil)
			if err != nil || txDetails.Meta == nil {
				continue
			}

			for _, tokenBalance := range txDetails.Meta.PostTokenBalances {
				if tokenBalance.Mint.String() == mint && tokenBalance.Owner != nil && *tokenBalance.Owner == relayerPubkey {
					amount = tokenBalance.UiTokenAmount.Amount
					break
				}
			}
		}

		// Calculate pending amount
		pendingAmount := amount
		if exists {
			// If existing allocation, add to pending amount
			pendingAmountInt := new(big.Int)
			pendingAmountInt.SetString(currentAlloc.PendingAmount, 10)
			newAmountInt := new(big.Int)
			newAmountInt.SetString(amount, 10)
			pendingAmountInt.Add(pendingAmountInt, newAmountInt)
			pendingAmount = pendingAmountInt.String()
		}

		// Update allocation
		currentAlloc.PendingAmount = pendingAmount
		currentAlloc.Pending = true
		if spent, ok := tokenSOLSpent[mint]; ok {
			currentAlloc.PurchasedSOL += spent
		}
		tokenAllocations[mint] = currentAlloc
	}

	// Convert map to slice for storage
	var allocations []models.TokenAllocation
	for _, alloc := range tokenAllocations {
		allocations = append(allocations, alloc)
	}

	// Calculate pending status for the bundle
	pendingBundle := false
	for _, alloc := range allocations {
		if alloc.Pending {
			pendingBundle = true
			break
		}
	}

	// Create or update user holding for this bundle
	userHolding := models.UserHolding{
		BundleID:    bundleId,
		BundleName:  bundle.BundleMeta.BundleName,
		InvestedSOL: existingHolding.InvestedSOL + totalTokenSOLSpent,
		Tokens:      allocations,
		Pending:     pendingBundle,
		Active:      true,
		Timestamp:   time.Now(),
	}

	// Start MongoDB session
	session, err := configs.DB.StartSession()
	if err != nil {
		tc.logger.Error("failed to start MongoDB session: ", "error", err)
		return fmt.Errorf("failed to start MongoDB session: %w", err)
	}
	defer session.EndSession(ctx)

	err = session.StartTransaction()
	if err != nil {
		tc.logger.Error("failed to start transaction: ", "error", err)
		return fmt.Errorf("failed to start transaction: %w", err)
	}

	// Prepare update operation
	update := bson.M{
		"$inc": bson.M{"totalInvestedSol": totalTokenSOLSpent},
		"$set": bson.M{"lastUpdated": time.Now(), "pending": pendingBundle},
	}

	// Add to deposits if new, or replace if existing
	if existingHolding == nil {
		update["$push"] = bson.M{"deposits": userHolding}
	} else {
		update["$set"].(bson.M)["deposits.$[elem]"] = userHolding
	}

	// Use arrayFilters for updating specific array element
	opts := options.Update().SetUpsert(true)
	if existingHolding != nil {
		opts.SetArrayFilters(options.ArrayFilters{
			Filters: []interface{}{bson.M{"elem.bundleId": bundleId}},
		})
	}

	_, err = userDepositCollection.UpdateOne(
		ctx,
		bson.M{"wallet": userWallet},
		update,
		opts,
	)

	if err != nil {
		session.AbortTransaction(ctx)
		return fmt.Errorf("failed to update user deposit: %w", err)
	}

	if err := session.CommitTransaction(ctx); err != nil {
		return fmt.Errorf("failed to commit transaction: %w", err)
	}

	tc.logger.Info("Successfully updated user holdings",
		"wallet", userWallet,
		"bundleID", bundleId,
		"tokensPurchased", len(allocations),
		"totalInvestedSOL", totalTokenSOLSpent,
		"pendingStatus", pendingBundle)

	return nil
}

func (tc *TokenController) logDebug(msg string, args ...any) {
	if tc.debug {
		tc.logger.Debug(msg, args...)
	}
}

func (tc *TokenController) logInfo(msg string, args ...any) {
	if tc.debug {
		tc.logger.Info(msg, args...)
	}
}



./controller/bundle_controller.go
package controllers

import (
	"context"
	"echo-mongo-api/configs"
	"echo-mongo-api/models"
	"echo-mongo-api/responses"
	"log"
	"net/http"
	"strconv"
	"time"

	"github.com/labstack/echo/v4"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
)

var bundleCollection *mongo.Collection = configs.GetCollection(configs.DB, "bundles")

func AddBundle(c echo.Context) error {
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	var bundle models.Bundle
	log.Printf("AddBundle :")
	// Validate the request body
	if err := c.Bind(&bundle); err != nil {
		log.Fatal(err)
		return c.JSON(http.StatusBadRequest, responses.BundleResponse{
			Status:  http.StatusBadRequest,
			Message: "error",
			Data:    &echo.Map{"data": err.Error()},
		})
	}

	// Use validator library to validate required fields
	if validationErr := validate.Struct(&bundle); validationErr != nil {
		log.Fatal(validationErr)
		return c.JSON(http.StatusBadRequest, responses.BundleResponse{
			Status:  http.StatusBadRequest,
			Message: "error",
			Data:    &echo.Map{"data": validationErr.Error()},
		})
	}

	// Validate timestamp (must be a numeric string)
	if _, err := strconv.ParseInt(bundle.Timestamp, 10, 64); err != nil {
		log.Fatal(err)
		return c.JSON(http.StatusBadRequest, responses.BundleResponse{
			Status:  http.StatusBadRequest,
			Message: "Invalid timestamp format (must be Unix timestamp as string)",
			Data:    &echo.Map{"data": err.Error()},
		})
	}

	// If timestamp is empty, set current time
	if bundle.Timestamp == "" {
		bundle.Timestamp = strconv.FormatInt(time.Now().Unix(), 10)
	}

	newBundle := models.Bundle{
		ID:              primitive.NewObjectID(),
		Bid:             bundle.Bid,
		BundleMeta:      bundle.BundleMeta,
		BundleAddress:   bundle.BundleAddress,
		BundleMemesInfo: bundle.BundleMemesInfo,
		Timestamp:       bundle.Timestamp,
	}

	// Insert the bundle
	result, err := bundleCollection.InsertOne(ctx, newBundle)
	if err != nil {
		log.Fatal(err)
		return c.JSON(http.StatusInternalServerError, responses.BundleResponse{
			Status:  http.StatusInternalServerError,
			Message: "error",
			Data:    &echo.Map{"data": err.Error()},
		})
	}
	// Return the inserted ID
	return c.JSON(http.StatusCreated, responses.BundleResponse{
		Status:  http.StatusCreated,
		Message: "success",
		Data:    &echo.Map{"data": result.InsertedID},
	})
}

// Get all bundles
func GetAllBundles(c echo.Context) error {
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	var bundles []models.Bundle

	// Find all bundles
	cursor, err := bundleCollection.Find(ctx, bson.M{})
	if err != nil {
		return c.JSON(http.StatusInternalServerError, responses.BundleResponse{
			Status:  http.StatusInternalServerError,
			Message: "error",
			Data:    &echo.Map{"data": err.Error()},
		})
	}
	defer cursor.Close(ctx)

	// Iterate through the cursor and decode each bundle
	for cursor.Next(ctx) {
		var bundle models.Bundle
		if err := cursor.Decode(&bundle); err != nil {
			return c.JSON(http.StatusInternalServerError, responses.BundleResponse{
				Status:  http.StatusInternalServerError,
				Message: "error",
				Data:    &echo.Map{"data": err.Error()},
			})
		}
		bundles = append(bundles, bundle)
	}

	// Check for cursor errors
	if err := cursor.Err(); err != nil {
		return c.JSON(http.StatusInternalServerError, responses.BundleResponse{
			Status:  http.StatusInternalServerError,
			Message: "error",
			Data:    &echo.Map{"data": err.Error()},
		})
	}

	return c.JSON(http.StatusOK, responses.BundleResponse{
		Status:  http.StatusOK,
		Message: "success",
		Data:    &echo.Map{"data": bundles},
	})
}


./controllers/meme_controller.go
package controllers

import (
	"context"
	"echo-mongo-api/configs"
	"echo-mongo-api/models"
	"echo-mongo-api/responses"
	"net/http"
	"time"

	"github.com/labstack/echo/v4"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
)

var memeCollection *mongo.Collection = configs.GetCollection(configs.DB, "memes")

func AddMeme(c echo.Context) error {
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	var meme models.Meme

	// Validate request body
	if err := c.Bind(&meme); err != nil {
		return c.JSON(http.StatusBadRequest, responses.MemeResponse{
			Status:  http.StatusBadRequest,
			Message: "error",
			Data:    &echo.Map{"data": err.Error()},
		})
	}

	// Validate required fields
	if validationErr := validate.Struct(&meme); validationErr != nil {
		return c.JSON(http.StatusBadRequest, responses.MemeResponse{
			Status:  http.StatusBadRequest,
			Message: "error",
			Data:    &echo.Map{"data": validationErr.Error()},
		})
	}

	// Set timestamps if not provided
	if meme.CreatedTs == "" {
		meme.CreatedTs = time.Now().Format(time.RFC3339)
	}
	meme.UpdatedTs = time.Now().Format(time.RFC3339)

	// Insert meme
	result, err := memeCollection.InsertOne(ctx, meme)
	if err != nil {
		return c.JSON(http.StatusInternalServerError, responses.MemeResponse{
			Status:  http.StatusInternalServerError,
			Message: "error",
			Data:    &echo.Map{"data": err.Error()},
		})
	}

	return c.JSON(http.StatusCreated, responses.MemeResponse{
		Status:  http.StatusCreated,
		Message: "success",
		Data:    &echo.Map{"data": result.InsertedID},
	})
}

func GetMemesByBid(c echo.Context) error {
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	bid := c.Param("bid")

	// Build filter
	filter := bson.M{"_bid": bid}

	// Find memes
	cursor, err := memeCollection.Find(ctx, filter)
	if err != nil {
		return c.JSON(http.StatusInternalServerError, responses.MemeResponse{
			Status:  http.StatusInternalServerError,
			Message: "error",
			Data:    &echo.Map{"data": err.Error()},
		})
	}
	defer cursor.Close(ctx)

	// Decode results
	var memes []models.Meme
	if err = cursor.All(ctx, &memes); err != nil {
		return c.JSON(http.StatusInternalServerError, responses.MemeResponse{
			Status:  http.StatusInternalServerError,
			Message: "error",
			Data:    &echo.Map{"data": err.Error()},
		})
	}

	return c.JSON(http.StatusOK, responses.MemeResponse{
		Status:  http.StatusOK,
		Message: "success",
		Data:    &echo.Map{"data": memes},
	})
}

func GetAllMemes(c echo.Context) error {
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Find all memes with empty filter
	cursor, err := memeCollection.Find(ctx, bson.M{})
	if err != nil {
		return c.JSON(http.StatusInternalServerError, responses.MemeResponse{
			Status:  http.StatusInternalServerError,
			Message: "error",
			Data:    &echo.Map{"data": err.Error()},
		})
	}
	defer cursor.Close(ctx)

	// Decode results
	var memes []models.Meme
	if err = cursor.All(ctx, &memes); err != nil {
		return c.JSON(http.StatusInternalServerError, responses.MemeResponse{
			Status:  http.StatusInternalServerError,
			Message: "error",
			Data:    &echo.Map{"data": err.Error()},
		})
	}

	return c.JSON(http.StatusOK, responses.MemeResponse{
		Status:  http.StatusOK,
		Message: "success",
		Data:    &echo.Map{"data": memes},
	})
}


./configs/setup.go
package configs

import (
	"context"
	"fmt"
	"log"
	"time"

	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

func ConnectDB() *mongo.Client {
	client, err := mongo.NewClient(options.Client().ApplyURI(EnvMongoURI()))
	if err != nil {
		log.Fatal(err)
	}

	ctx, _ := context.WithTimeout(context.Background(), 10*time.Second)
	err = client.Connect(ctx)
	if err != nil {
		log.Fatal(err)
	}

	//ping the database
	err = client.Ping(ctx, nil)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println("Connected to MongoDB")
	return client
}

// Client instance
var DB *mongo.Client = ConnectDB()

// getting database collections
func GetCollection(client *mongo.Client, collectionName string) *mongo.Collection {
	collection := client.Database("db-wolfindex").Collection(collectionName)
	return collection
}


./configs/env.go
package configs

import (
	"log"
	"os"

	"github.com/joho/godotenv"
)

func EnvMongoURI() string {
	err := godotenv.Load()
	if err != nil {
		log.Fatal("Error loading .env file")
	}

	return os.Getenv("MONGOURI")
}

func EnvPORT() string {
	err := godotenv.Load()
	if err != nil {
		log.Fatal("Error loading .env file")
	}

	return os.Getenv("PORT")
}

func EnvSolanaRPC() string {
	err := godotenv.Load()
	if err != nil {
		log.Fatal("Error loading .env file")
	}

	return os.Getenv("HELIUS_RPC_URL")
}

func EnvRelayerPrivateKey() string {
	err := godotenv.Load()
	if err != nil {
		log.Fatal("Error loading .env file")
	}

	return os.Getenv("RELAYER_PRIVATE_KEY")
}

func EnvJitoTipAccount() string {
	err := godotenv.Load()
	if err != nil {
		log.Fatal("Error loading .env file")
	}

	return os.Getenv("JITO_TIP_ACCOUNT")
}

func EnvRaydiumAPI() string {
	err := godotenv.Load()
	if err != nil {
		log.Fatal("Error loading .env file")
	}
	return os.Getenv("RAYDIUM_API_URL")
}

func EnvJitoAPI() string {
	err := godotenv.Load()
	if err != nil {
		log.Fatal("Error loading .env file")
	}
	return os.Getenv("JITO_API_URL")
}


./models/bundle_model.go
package controllers

import (
	"context"
	"echo-mongo-api/configs"
	"echo-mongo-api/models"
	"echo-mongo-api/responses"
	"net/http"
	"time"

	"github.com/labstack/echo/v4"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
)

var memeCollection *mongo.Collection = configs.GetCollection(configs.DB, "memes")

func AddMeme(c echo.Context) error {
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	var meme models.Meme

	// Validate request body
	if err := c.Bind(&meme); err != nil {
		return c.JSON(http.StatusBadRequest, responses.MemeResponse{
			Status:  http.StatusBadRequest,
			Message: "error",
			Data:    &echo.Map{"data": err.Error()},
		})
	}

	// Validate required fields
	if validationErr := validate.Struct(&meme); validationErr != nil {
		return c.JSON(http.StatusBadRequest, responses.MemeResponse{
			Status:  http.StatusBadRequest,
			Message: "error",
			Data:    &echo.Map{"data": validationErr.Error()},
		})
	}

	// Set timestamps if not provided
	if meme.CreatedTs == "" {
		meme.CreatedTs = time.Now().Format(time.RFC3339)
	}
	meme.UpdatedTs = time.Now().Format(time.RFC3339)

	// Insert meme
	result, err := memeCollection.InsertOne(ctx, meme)
	if err != nil {
		return c.JSON(http.StatusInternalServerError, responses.MemeResponse{
			Status:  http.StatusInternalServerError,
			Message: "error",
			Data:    &echo.Map{"data": err.Error()},
		})
	}

	return c.JSON(http.StatusCreated, responses.MemeResponse{
		Status:  http.StatusCreated,
		Message: "success",
		Data:    &echo.Map{"data": result.InsertedID},
	})
}

func GetMemesByBid(c echo.Context) error {
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	bid := c.Param("bid")

	// Build filter
	filter := bson.M{"_bid": bid}

	// Find memes
	cursor, err := memeCollection.Find(ctx, filter)
	if err != nil {
		return c.JSON(http.StatusInternalServerError, responses.MemeResponse{
			Status:  http.StatusInternalServerError,
			Message: "error",
			Data:    &echo.Map{"data": err.Error()},
		})
	}
	defer cursor.Close(ctx)

	// Decode results
	var memes []models.Meme
	if err = cursor.All(ctx, &memes); err != nil {
		return c.JSON(http.StatusInternalServerError, responses.MemeResponse{
			Status:  http.StatusInternalServerError,
			Message: "error",
			Data:    &echo.Map{"data": err.Error()},
		})
	}

	return c.JSON(http.StatusOK, responses.MemeResponse{
		Status:  http.StatusOK,
		Message: "success",
		Data:    &echo.Map{"data": memes},
	})
}

func GetAllMemes(c echo.Context) error {
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Find all memes with empty filter
	cursor, err := memeCollection.Find(ctx, bson.M{})
	if err != nil {
		return c.JSON(http.StatusInternalServerError, responses.MemeResponse{
			Status:  http.StatusInternalServerError,
			Message: "error",
			Data:    &echo.Map{"data": err.Error()},
		})
	}
	defer cursor.Close(ctx)

	// Decode results
	var memes []models.Meme
	if err = cursor.All(ctx, &memes); err != nil {
		return c.JSON(http.StatusInternalServerError, responses.MemeResponse{
			Status:  http.StatusInternalServerError,
			Message: "error",
			Data:    &echo.Map{"data": err.Error()},
		})
	}

	return c.JSON(http.StatusOK, responses.MemeResponse{
		Status:  http.StatusOK,
		Message: "success",
		Data:    &echo.Map{"data": memes},
	})
}


./modles/meme_model.go
package models

import (
	"go.mongodb.org/mongo-driver/bson/primitive"
)

type MemeSocials struct {
	Website  string `json:"website" bson:"website"`
	Twitter  string `json:"twitter" bson:"twitter"`
	Telegram string `json:"telegram" bson:"telegram"`
}

type Meme struct {
	ID          primitive.ObjectID `json:"_id,omitempty" bson:"_id,omitempty"`
	Bid         string             `json:"_bid" bson:"_bid" validate:"required"`
	MemeName    string             `json:"memeName" bson:"memeName" validate:"required"`
	MemeTicker  string             `json:"memeTicker" bson:"memeTicker" validate:"required"`
	MemeAddress string             `json:"memeAddress" bson:"memeAddress" validate:"required"`
	MemeLogo    string             `json:"memeLogo" bson:"memeLogo"`
	MemeSocials MemeSocials        `json:"memeSocials" bson:"memeSocials"`
	CreatedTs   string             `json:"createdTs" bson:"createdTs" validate:"required"`
	UpdatedTs   string             `json:"updatedTs" bson:"updatedTs"`
}


./responses/bundle_response.go
package responses

import "github.com/labstack/echo/v4"

type BundleResponse struct {
	Status  int       `json:"status"`
	Message string    `json:"message"`
	Data    *echo.Map `json:"data"`
}


./responses/meme_response.go
package responses

import "github.com/labstack/echo/v4"

type MemeResponse struct {
	Status  int       `json:"status"`
	Message string    `json:"message"`
	Data    *echo.Map `json:"data"`
}

./responses/token_response.go
package responses

import "github.com/labstack/echo/v4"

type TokenResponse struct {
	Status  int       `json:"status"`
	Message string    `json:"message"`
	Data    *echo.Map `json:"data"`
}


./routes/bundle_route.go
package routes

import (
	"echo-mongo-api/controllers"

	"github.com/labstack/echo/v4"
)

func BundleRoute(g *echo.Group) {
	g.POST("/addBundle", controllers.AddBundle)
	g.GET("/bundles", controllers.GetAllBundles)
}

./routes/meme_route.go
package routes

import (
	"echo-mongo-api/controllers"

	"github.com/labstack/echo/v4"
)

func MemeRoute(g *echo.Group) {
	g.POST("/addMeme", controllers.AddMeme)
	g.GET("/getMemes/:bid", controllers.GetMemesByBid)
	g.GET("/memes", controllers.GetAllMemes)
}

./routes/user_route.go
package routes

import (
	"echo-mongo-api/controllers"
	"echo-mongo-api/services"

	"github.com/gagliardetto/solana-go/rpc"
	"github.com/gagliardetto/solana-go/rpc/ws"
	"github.com/labstack/echo/v4"
)

func TokenRoute(g *echo.Group, jupiterService *services.JupiterService, helperService *services.HelperService, jitoService *services.JitoService, rpcClient *rpc.Client, wsClient *ws.Client) {
	tokenController := controllers.NewTokenController(helperService, jupiterService, jitoService, rpcClient, wsClient)

	g.POST("/buy-tokens", tokenController.BuyTokens)
}

./main.go
package main

import (
	"context"
	"echo-mongo-api/configs"
	"echo-mongo-api/routes"
	"echo-mongo-api/services"
	"log"

	"github.com/gagliardetto/solana-go/rpc"
	"github.com/gagliardetto/solana-go/rpc/ws"
	"github.com/ilkamo/jupiter-go/jupiter"
	jitorpc "github.com/jito-labs/jito-go-rpc"
	"github.com/labstack/echo/v4"
	"github.com/labstack/echo/v4/middleware"
)

func main() {
	e := echo.New()

	// Configure CORS middleware
	e.Use(middleware.CORSWithConfig(middleware.CORSConfig{
		AllowOrigins:     []string{"http://localhost:3000" /*"https://wolftech-backend.onrender.com/api"*/},
		AllowCredentials: true,
		MaxAge:           86400, // 24 hours
	}))
	//run database
	configs.ConnectDB()

	// Initialize Solana RPC client
	rpcClient := rpc.New(configs.EnvSolanaRPC())

	// Create a new WS client (used for confirming transactions)
	wsClient, err := ws.Connect(context.Background(), rpc.MainNetBeta_WS)
	if err != nil {
		panic(err)
	}

	jupClient, err := jupiter.NewClientWithResponses(jupiter.DefaultAPIURL)
	if err != nil {
		panic(err)
	}

	jitoClient := jitorpc.NewJitoJsonRpcClient(configs.EnvJitoAPI(), "")

	// Initialize Raydium service
	jupiterService := services.NewJupiterService(jupClient)

	// Initialize Helper service
	helperService := services.NewHelperService(rpcClient, wsClient)

	// Initialize Helper service
	jitoService := services.NewJitoService(jitoClient)

	//routes
	api := e.Group("/api") // Create API route group
	routes.UserRoute(api)
	routes.BundleRoute(api)
	routes.MemeRoute(api)
	routes.TokenRoute(
		api,
		jupiterService,
		helperService,
		jitoService,
		rpcClient,
		wsClient,
	)

	port := configs.EnvPORT()
	log.Printf("Server starting at :%s", port)
	e.Logger.Fatal(e.Start(":" + port))
}
